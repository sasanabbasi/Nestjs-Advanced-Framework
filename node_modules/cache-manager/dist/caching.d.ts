import { MemoryCache, MemoryConfig } from './stores';
export declare type Config = {
    ttl?: Ttl;
    isCacheable?: (val: unknown) => boolean;
};
export declare type Ttl = number;
export declare type Store = {
    get<T>(key: string): Promise<T | undefined>;
    set<T>(key: string, data: T, ttl?: Ttl): Promise<void>;
    del(key: string): Promise<void>;
    reset(): Promise<void>;
    mset(args: [string, unknown][], ttl?: Ttl): Promise<void>;
    mget(...args: string[]): Promise<unknown[]>;
    mdel(...args: string[]): Promise<void>;
    keys(pattern?: string): Promise<string[]>;
    ttl(key: string): Promise<number>;
};
export declare type StoreConfig = Config;
export declare type FactoryConfig<T> = T & Config;
export declare type FactoryStore<S extends Store, T extends object = never> = (config?: FactoryConfig<T>) => S | Promise<S>;
export declare type Stores<S extends Store, T extends object> = 'memory' | Store | FactoryStore<S, T>;
export declare type CachingConfig<T> = MemoryConfig | StoreConfig | FactoryConfig<T>;
export declare type Cache<S extends Store = Store> = {
    set: (key: string, value: unknown, ttl?: Ttl) => Promise<void>;
    get: <T>(key: string) => Promise<T | undefined>;
    del: (key: string) => Promise<void>;
    reset: () => Promise<void>;
    wrap<T>(key: string, fn: () => Promise<T>, ttl?: Ttl): Promise<T>;
    store: S;
};
export declare function caching(name: 'memory', args?: MemoryConfig): Promise<MemoryCache>;
export declare function caching<S extends Store>(store: S): Promise<Cache<S>>;
export declare function caching<S extends Store, T extends object = never>(factory: FactoryStore<S, T>, args?: FactoryConfig<T>): Promise<Cache<S>>;
